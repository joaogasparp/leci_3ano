<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="css/styles.css" />
    <title>hi</title>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.js",
          "three/orbitcontrols": "https://threejs.org/examples/jsm/controls/OrbitControls.js",
          "three/pointerlockcontrols": "https://threejs.org/examples/jsm/controls/PointerLockControls.js",
          "three/gltfloader": "https://threejs.org/examples/jsm/loaders/GLTFLoader.js",
          "cannon-es": "https://cdn.skypack.dev/cannon-es",
          "three/tgaloader": "https://threejs.org/examples/jsm/loaders/TGALoader.js",
          "three/rgbeloader": "https://threejs.org/examples/jsm/loaders/RGBELoader.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import * as CANNON from "cannon-es";
      import { OrbitControls } from "three/orbitcontrols";
      import { PointerLockControls } from "three/pointerlockcontrols";
      import { GLTFLoader } from "three/gltfloader";
      import { TGALoader } from "three/tgaloader";
      import { RGBELoader } from "three/rgbeloader";

      // =================== SCENE ===================

      const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
      let scene = new THREE.Scene();
      let renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      let camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      );
      camera.position.z = 5000;
      const controls = new PointerLockControls(camera, renderer.domElement);
      scene.add(controls.getObject());

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
      scene.add(ambientLight);

      const sky = new THREE.Mesh(
        new THREE.SphereGeometry(1000, 32, 32),
        new THREE.MeshBasicMaterial({
          color: 0x000c19,
          side: THREE.DoubleSide,
        })
      );
      scene.add(sky);

      scene.fog = new THREE.FogExp2(0xDFE9F3, 0.004);

      function createScene() {
        const directional1Light = new THREE.DirectionalLight(0xffffff, 0.4);
        directional1Light.castShadow = true;
        directional1Light.position.set(25, 50, 25);
        scene.add(directional1Light);

        const sun1Geometry = new THREE.SphereGeometry(10, 50, 50);
        const sun1Material = new THREE.MeshPhongMaterial({
          emissive: 0xbac3ca,
          emissiveIntensity: 5,
        });
        const sun1 = new THREE.Mesh(sun1Geometry, sun1Material);
        sun1.position.set(25, 50, 25);
        scene.add(sun1);

        return scene;
      }

      createScene();

      function createStars() {
        const stars = new THREE.Group();
        const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Cor branca para as estrelas
        const numStars = 2000; // Número de estrelas a serem criadas

        for (let i = 0; i < numStars; i++) {
          const starGeometry = new THREE.SphereGeometry(
            Math.random() * 0.5,
            12,
            12
          ); // Tamanho aleatório para as estrelas
          const star = new THREE.Mesh(starGeometry, starMaterial);

          // Posiciona as estrelas aleatoriamente no céu
          star.position.set(
            (Math.random() - 0.5) * 1000, // Posição x aleatória
            Math.random() * 500 + 50, // Posição y aleatória (acima do chão)
            (Math.random() - 0.5) * 1000 // Posição z aleatória
          );

          stars.add(star);
        }

        return stars;
      }

      // Adiciona as estrelas à cena
      const stars = createStars();
      scene.add(stars);

      // =================== SCENE ===================
      // ====================================================================================================================
      // =================== PLAYER ===================

      const playerBody = new CANNON.Body({
        mass: 50, // kg
        shape: new CANNON.Sphere(0.5),
      });
      playerBody.quaternion.set(Math.PI / 10, Math.PI / 4, 0, 2);
      world.addBody(playerBody);

      const playerGeometry = new THREE.BoxGeometry(0.01, 0.01, 0.01);
      const playerMaterial = new THREE.MeshPhongMaterial({ color: 0xfafafa });
      const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
      playerMesh.castShadow = true;
      playerMesh.receiveShadow = true;
      scene.add(playerMesh);

      playerMesh.position.set(0, 0.1, 0);

      const keyboard = {};
      document.addEventListener("keydown", (event) => {
        keyboard[event.keyCode] = true;
      });
      document.addEventListener("keyup", (event) => {
        keyboard[event.keyCode] = false;
      });

      document.addEventListener(
        "click",
        function () {
          controls.lock();
        },
        false
      );

      let direction = new THREE.Vector3();
      let verticalSpeed = 0;
      let jumpSpeed = 0.1;
      let canJump = true;

      function updatePlayerPosition() {
        const speed = 0.1;

        controls.getDirection(direction);

        direction.y = 0;
        direction.normalize();

        if (keyboard[87]) playerMesh.position.addScaledVector(direction, speed);
        if (keyboard[83])
          playerMesh.position.addScaledVector(direction, -speed);
        if (keyboard[65])
          playerMesh.position.addScaledVector(
            new THREE.Vector3().crossVectors(
              new THREE.Vector3(0, 1, 0),
              direction
            ),
            speed
          );
        if (keyboard[68])
          playerMesh.position.addScaledVector(
            new THREE.Vector3().crossVectors(
              new THREE.Vector3(0, 1, 0),
              direction
            ),
            -speed
          );

        if (keyboard[32] && canJump) {
          verticalSpeed = jumpSpeed;
          canJump = false;
        }

        playerMesh.position.y += verticalSpeed;

        verticalSpeed -= 0.005;

        if (playerMesh.position.y <= 0.5) {
          playerMesh.position.y = 0.5;
          canJump = true;
          verticalSpeed = 0;
        }
      }

      // =================== PLAYER ===================
      // ====================================================================================================================
      // =================== GROUND ===================

      const groundBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
      });
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(groundBody);

      var grassTexture = new THREE.TextureLoader().load(
        "assets/grass.png",
        function (texture) {
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(50, 50);
        }
      );
      var groundMaterial = new THREE.MeshPhongMaterial({ map: grassTexture });

      var groundGeometry = new THREE.CircleGeometry(100, 32);

      var groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
      groundMesh.rotation.x = -Math.PI / 2;
      scene.add(groundMesh);

      // =================== GROUND ===================
      // ====================================================================================================================

      const loaderGLTF = new GLTFLoader();

      // function createGrass1AtPosition(x, y, z) {
      //   loaderGLTF.load(
      //     "models/grass1.glb",
      //     function (gltf) {
      //       const grass = gltf.scene;
      //       grass.position.set(x, y, z);
      //       scene.add(grass);
      //     },
      //     function (xhr) {
      //       console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
      //     },
      //     function (error) {
      //       console.log("An error happened");
      //     }
      //   );
      // }

      function createGrass2AtPosition(x, y, z) {
        loaderGLTF.load(
          "models/grass2.glb",
          function (gltf) {
            const grass = gltf.scene;
            grass.position.set(x, y, z);
            scene.add(grass);
          },
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          },
          function (error) {
            console.log("An error happened");
          }
        );
      }

      function createGrasses(numGrass1, numGrass2, minDistance) {
        const positions = [];
        const grassRadius = 100;

        // for (let i = 0; i < numGrass1; i++) {
        //   let position = generatePosition(positions, grassRadius, minDistance);
        //   positions.push(position);
        //   createGrass1AtPosition(position.x, 0, position.z);
        // }

        for (let i = 0; i < numGrass2; i++) {
          let position = generatePosition(positions, grassRadius, minDistance);
          positions.push(position);
          createGrass2AtPosition(position.x, 0, position.z);
        }
      }

      createGrasses(0, 40, 5);

      // ====================================================================================================================
      // ===================== TREE =====================

      // const treeBody1 = new CANNON.Body({
      //   type: CANNON.Body.STATIC,
      //   shape: new CANNON.Plane(),
      // });
      // treeBody1.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      // world.addBody(treeBody1);

      // loader.load(
      //   "models/tree1.glb",
      //   function (gltf) {
      //     const tree = gltf.scene;
      //     tree.position.set(5, 0, 5);
      //     tree.scale.set(0.4, 0.4, 0.4);
      //     scene.add(tree);
      //   },
      //   function (xhr) {
      //     console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
      //   },
      //   function (error) {
      //     console.log("An error happened");
      //   }
      // );

      // const treeBody2 = new CANNON.Body({
      //   type: CANNON.Body.STATIC,
      //   shape: new CANNON.Plane(),
      // });
      // treeBody2.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      // world.addBody(treeBody2);

      // loader.load(
      //   "models/tree2.glb",
      //   function (gltf) {
      //     const tree = gltf.scene;
      //     tree.position.set(-5, 3.8, -15);
      //     tree.scale.set(3, 3, 3);
      //     scene.add(tree);
      //   },
      //   function (xhr) {
      //     console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
      //   },
      //   function (error) {
      //     console.log("An error happened");
      //   }
      // );

      function createTree4AtPosition(x, y, z) {
        loaderGLTF.load(
          "models/tree4.glb",
          function (gltf) {
            const tree = gltf.scene;
            tree.position.set(x, y, z);
            tree.scale.set(0.08, 0.08, 0.08);
            scene.add(tree);
          },
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          },
          function (error) {
            console.log("An error happened");
          }
        );
      }

      function createTree5AtPosition(x, y, z) {
        loaderGLTF.load(
          "models/tree5.glb",
          function (gltf) {
            const tree = gltf.scene;
            tree.position.set(x, y, z);
            scene.add(tree);
          },
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          },
          function (error) {
            console.log("An error happened");
          }
        );
      }

      function createTree6AtPosition(x, y, z) {
        loaderGLTF.load(
          "models/tree6.glb",
          function (gltf) {
            const tree = gltf.scene;
            tree.position.set(x, y, z);
            scene.add(tree);
          },
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          },
          function (error) {
            console.log("An error happened");
          }
        );
      }

      function createTreeS1AtPosition(x, y, z) {
        loaderGLTF.load(
          "models/treeS1.glb",
          function (gltf) {
            const tree = gltf.scene;
            tree.position.set(x, y, z);
            tree.scale.set(2, 2, 2);
            scene.add(tree);
          },
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          },
          function (error) {
            console.log("An error happened");
          }
        );
      }

      const playerHeight = 3.0;

      function createTree(x, y, z) {
        const heightScale = Math.random() * 0.5 + 0.75;

        const trunkColor = new THREE.Color(0x6f4118);
        const leafColor = new THREE.Color(0x3a6919);

        const cylinderRadius = playerHeight / 4;
        const cylinderHeight = playerHeight * 2 * heightScale;
        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          32
        );
        const brownMaterial = new THREE.MeshPhongMaterial({
          color: trunkColor,
          shininess: 100,
        });
        const cylinder = new THREE.Mesh(cylinderGeometry, brownMaterial);
        cylinder.position.y = cylinderHeight / 2.0;

        const baseConeRadius = playerHeight / 2;
        const coneHeight = playerHeight * 3 * heightScale;
        const coneGeometry = new THREE.ConeGeometry(
          baseConeRadius,
          coneHeight,
          32
        );
        const greenMaterial = new THREE.MeshPhongMaterial({
          color: leafColor,
          shininess: 100,
        });
        const cone = new THREE.Mesh(coneGeometry, greenMaterial);
        cone.position.y = cylinderHeight + coneHeight / 2.0;

        const tree = new THREE.Group();
        tree.add(cylinder);
        tree.add(cone);
        tree.position.set(x, y, z);
        scene.add(tree);
      }

      function createForest(
        numTrees4,
        numTrees5,
        numTrees6,
        numTreesS1,
        numTrees,
        minDistance
      ) {
        const positions = [];
        const forestRadius = 100;

        for (let i = 0; i < numTrees4; i++) {
          let position = generatePosition(positions, forestRadius, minDistance);
          positions.push(position);
          createTree4AtPosition(position.x, 0, position.z);
        }

        for (let i = 0; i < numTrees5; i++) {
          let position = generatePosition(positions, forestRadius, minDistance);
          positions.push(position);
          createTree5AtPosition(position.x, 0, position.z);
        }

        for (let i = 0; i < numTrees6; i++) {
          let position = generatePosition(positions, forestRadius, minDistance);
          positions.push(position);
          createTree6AtPosition(position.x, 0, position.z);
        }

        for (let i = 0; i < numTreesS1; i++) {
          let position = generatePosition(positions, forestRadius, minDistance);
          positions.push(position);
          createTreeS1AtPosition(position.x, 0, position.z);
        }

        for (let i = 0; i < numTrees; i++) {
          let position = generatePosition(positions, forestRadius, minDistance);
          positions.push(position);
          createTree(position.x, 0, position.z);
        }
      }

      function generatePosition(positions, forestRadius, minDistance) {
        let position;
        while (true) {
          const angle = Math.random() * Math.PI * 2;
          const radius = forestRadius * Math.sqrt(Math.random());
          position = {
            x: radius * Math.cos(angle),
            z: radius * Math.sin(angle),
          };

          let isFarEnough = true;
          for (let j = 0; j < positions.length; j++) {
            const otherPosition = positions[j];
            const distance = Math.sqrt(
              Math.pow(position.x - otherPosition.x, 2) +
                Math.pow(position.z - otherPosition.z, 2)
            );
            if (distance < minDistance) {
              isFarEnough = false;
              break;
            }
          }
          if (isFarEnough) {
            break;
          }
        }
        return position;
      }

      createForest(8, 8, 10, 2, 60, 15);

      // function createForest() {
      //   const forest = new THREE.Group();
      //   const numTrees = 100;
      //   const forestRadius = 100; // Raio do círculo do plano
      //   const minDistanceBetweenTrees = 5;

      //   for (let i = 0; i < numTrees; i++) {
      //     let tree = createTree();
      //     let position;
      //     while (true) {
      //       // Gere uma posição aleatória dentro do círculo
      //       const angle = Math.random() * Math.PI * 2;
      //       const radius = forestRadius * Math.sqrt(Math.random());
      //       position = {
      //         x: radius * Math.cos(angle),
      //         z: radius * Math.sin(angle),
      //       };

      //       let isFarEnough = true;
      //       for (let j = 0; j < forest.children.length; j++) {
      //         const otherTree = forest.children[j];
      //         const distance = Math.sqrt(
      //           Math.pow(position.x - otherTree.position.x, 2) +
      //             Math.pow(position.z - otherTree.position.z, 2)
      //         );
      //         if (distance < minDistanceBetweenTrees) {
      //           isFarEnough = false;
      //           break;
      //         }
      //       }
      //       if (isFarEnough) {
      //         break;
      //       }
      //     }
      //     tree.position.x = position.x;
      //     tree.position.z = position.z;
      //     forest.add(tree);
      //   }
      //   return forest;
      // }

      // const forest = createForest();
      // scene.add(forest);

      // ===================== TREE =====================
      // ====================================================================================================================
      // ===================== HOUSE =====================

      loaderGLTF.load(
        "models/house2.glb",
        function (gltf) {
          const house = gltf.scene;
          house.position.set(-40, 0, -50);
          house.scale.set(30, 30, 30);
          house.rotation.y = Math.PI;
          scene.add(house);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          console.log("An error happened");
        }
      );

      // ===================== HOUSE =====================
      // ====================================================================================================================
      // ===================== TOWER1 =====================

      const towerBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
      });
      towerBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(towerBody);

      loaderGLTF.load(
        "models/tower.glb",
        function (gltf) {
          const tower = gltf.scene;
          tower.position.set(-15, 0, -60);
          tower.rotation.y = Math.PI / 4;
          tower.scale.set(1.5, 1.5, 1.5);
          scene.add(tower);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          console.log("An error happened");
        }
      );

      // ===================== TOWER1 =====================
      // ====================================================================================================================
      // ===================== CASTLE =====================

      // ===================== CASTLE =====================
      // ====================================================================================================================
      // =================== ANIMATION ===================

      function animate() {
        requestAnimationFrame(animate);

        updatePlayerPosition();
        camera.position.copy(playerMesh.position);
        camera.position.y += 1.2;

        // treeBody1.position.copy(treeBody1.position);
        // treeBody1.quaternion.copy(treeBody1.quaternion);

        // treeBody2.position.copy(treeBody2.position);
        // treeBody2.quaternion.copy(treeBody2.quaternion);

        playerBody.position.copy(playerMesh.position);
        playerBody.quaternion.copy(playerMesh.quaternion);

        world.fixedStep();

        renderer.render(scene, camera);
      }
      animate();

      // =================== ANIMATION ===================
    </script>
  </body>
</html>

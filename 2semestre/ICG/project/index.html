<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="css/styles.css" />
    <title>hi</title>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.js",
          "three/orbitcontrols": "https://threejs.org/examples/jsm/controls/OrbitControls.js",
          "three/pointerlockcontrols": "https://threejs.org/examples/jsm/controls/PointerLockControls.js",
          "three/gltfloader": "https://threejs.org/examples/jsm/loaders/GLTFLoader.js",
          "cannon-es": "https://cdn.skypack.dev/cannon-es"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import * as CANNON from "cannon-es";
      import { OrbitControls } from "three/orbitcontrols";
      import { PointerLockControls } from "three/pointerlockcontrols";
      import { GLTFLoader } from "three/gltfloader";

      // =================== SCENE ===================

      const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
      let scene = new THREE.Scene();
      let renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      let camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      );
      camera.position.z = 5000;
      const controls = new PointerLockControls(camera, renderer.domElement);
      scene.add(controls.getObject());

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      let materialArray = [];
      let texture_ft = new THREE.TextureLoader().load(
        "assets/skybox/heather_ft.jpg"
      );
      let texture_bk = new THREE.TextureLoader().load(
        "assets/skybox/heather_bk.jpg"
      );
      let texture_up = new THREE.TextureLoader().load(
        "assets/skybox/heather_up.jpg"
      );
      let texture_dn = new THREE.TextureLoader().load(
        "assets/skybox/heather_dn.jpg"
      );
      let texture_rt = new THREE.TextureLoader().load(
        "assets/skybox/heather_rt.jpg"
      );
      let texture_lf = new THREE.TextureLoader().load(
        "assets/skybox/heather_lf.jpg"
      );

      materialArray.push(new THREE.MeshBasicMaterial({ map: texture_ft }));
      materialArray.push(new THREE.MeshBasicMaterial({ map: texture_bk }));
      materialArray.push(new THREE.MeshBasicMaterial({ map: texture_up }));
      materialArray.push(new THREE.MeshBasicMaterial({ map: texture_dn }));
      materialArray.push(new THREE.MeshBasicMaterial({ map: texture_rt }));
      materialArray.push(new THREE.MeshBasicMaterial({ map: texture_lf }));

      for (let i = 0; i < 6; i++) materialArray[i].side = THREE.BackSide;
      let skyboxGeo = new THREE.BoxGeometry(10000, 10000, 10000);
      let skybox = new THREE.Mesh(skyboxGeo, materialArray);
      scene.add(skybox);

      // =================== SCENE ===================
      // ====================================================================================================================
      // =================== PLAYER ===================

      const playerBody = new CANNON.Body({
        mass: 50, // kg
        shape: new CANNON.Sphere(0.5),
      });
      playerBody.quaternion.set(Math.PI / 10, Math.PI / 4, 0, 2);
      world.addBody(playerBody);

      const playerGeometry = new THREE.BoxGeometry(0.01, 0.01, 0.01);
      const playerMaterial = new THREE.MeshPhongMaterial({ color: 0xfafafa });
      const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
      playerMesh.castShadow = true;
      playerMesh.receiveShadow = true;
      scene.add(playerMesh);

      playerMesh.position.set(0, 0.1, 0);

      const keyboard = {};
      document.addEventListener("keydown", (event) => {
        keyboard[event.keyCode] = true;
      });
      document.addEventListener("keyup", (event) => {
        keyboard[event.keyCode] = false;
      });

      document.addEventListener(
        "click",
        function () {
          controls.lock();
        },
        false
      );

      let direction = new THREE.Vector3();
      let verticalSpeed = 0;
      let jumpSpeed = 0.1;
      let canJump = true;

      function updatePlayerPosition() {
        const speed = 0.1;

        controls.getDirection(direction);

        direction.y = 0;
        direction.normalize();

        if (keyboard[87]) playerMesh.position.addScaledVector(direction, speed);
        if (keyboard[83])
          playerMesh.position.addScaledVector(direction, -speed);
        if (keyboard[65])
          playerMesh.position.addScaledVector(
            new THREE.Vector3().crossVectors(
              new THREE.Vector3(0, 1, 0),
              direction
            ),
            speed
          );
        if (keyboard[68])
          playerMesh.position.addScaledVector(
            new THREE.Vector3().crossVectors(
              new THREE.Vector3(0, 1, 0),
              direction
            ),
            -speed
          );

        if (keyboard[32] && canJump) {
          verticalSpeed = jumpSpeed;
          canJump = false;
        }

        playerMesh.position.y += verticalSpeed;

        verticalSpeed -= 0.005;

        if (playerMesh.position.y <= 0.5) {
          playerMesh.position.y = 0.5;
          canJump = true;
          verticalSpeed = 0;
        }
      }

      // =================== PLAYER ===================
      // ====================================================================================================================
      // =================== GROUND ===================

      const groundBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
      });
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(groundBody);

      const loader = new GLTFLoader();
      loader.load(
        "models/grass.glb",
        function (gltf) {
          const grass = gltf.scene;
          scene.add(grass);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          console.log("An error happened");
        }
      );

      // =================== GROUND ===================
      // ====================================================================================================================
      // ===================== TREE =====================

      const treeBody1 = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
      });
      treeBody1.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(treeBody1);

      loader.load(
        "models/tree1.glb",
        function (gltf) {
          const tree = gltf.scene;
          tree.position.set(5, 0, 5);
          tree.scale.set(0.4, 0.4, 0.4);
          scene.add(tree);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          console.log("An error happened");
        }
      );

      const treeBody2 = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
      });
      treeBody2.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(treeBody2);

      loader.load(
        "models/tree2.glb",
        function (gltf) {
          const tree = gltf.scene;
          tree.position.set(-5, 4, -15);
          tree.scale.set(3, 3, 3);
          scene.add(tree);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          console.log("An error happened");
        }
      );

      const playerHeight = 2.5;

      function createTree() {
        const heightScale = Math.random() * 0.5 + 0.75;

        const trunkColor = new THREE.Color(0x6f4118);
        const leafColor = new THREE.Color(0x3a6919);

        const cylinderRadius = playerHeight / 4;
        const cylinderHeight = playerHeight * 2 * heightScale;
        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          32
        );
        const brownMaterial = new THREE.MeshPhongMaterial({
          color: trunkColor,
          shininess: 100,
        });
        const cylinder = new THREE.Mesh(cylinderGeometry, brownMaterial);
        cylinder.position.y = cylinderHeight / 2.0;

        const baseConeRadius = playerHeight / 2;
        const coneHeight = playerHeight * 3 * heightScale;
        const coneGeometry = new THREE.ConeGeometry(
          baseConeRadius,
          coneHeight,
          32
        );
        const greenMaterial = new THREE.MeshPhongMaterial({
          color: leafColor,
          shininess: 100,
        });
        const cone = new THREE.Mesh(coneGeometry, greenMaterial);
        cone.position.y = cylinderHeight + coneHeight / 2.0;

        const tree = new THREE.Group();
        tree.add(cylinder);
        tree.add(cone);
        return tree;
      }

      function createForest() {
        const forest = new THREE.Group();
        const numTrees = 100;
        const forestSize = 200;
        const minDistanceBetweenTrees = 5;

        for (let i = 0; i < numTrees; i++) {
          let tree = createTree();
          let position;
          while (true) {
            position = {
              x: Math.random() * forestSize - forestSize / 2,
              z: Math.random() * forestSize - forestSize / 2,
            };

            let isFarEnough = true;
            for (let j = 0; j < forest.children.length; j++) {
              const otherTree = forest.children[j];
              const distance = Math.sqrt(
                Math.pow(position.x - otherTree.position.x, 2) +
                  Math.pow(position.z - otherTree.position.z, 2)
              );
              if (distance < minDistanceBetweenTrees) {
                isFarEnough = false;
                break;
              }
            }
            if (isFarEnough) {
              break;
            }
          }
          tree.position.x = position.x;
          tree.position.z = position.z;
          forest.add(tree);
        }
        return forest;
      }

      const forest = createForest();
      scene.add(forest);

      // ===================== TREE =====================
      // ====================================================================================================================
      // ===================== HOUSE =====================

      const houseBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
      });
      houseBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(houseBody);

      loader.load(
        "models/house1.glb",
        function (gltf) {
          const house = gltf.scene;
          house.position.set(-3, -0.4, 5);
          house.rotation.y = Math.PI / 4;
          house.scale.set(0.37, 0.37, 0.37);
          scene.add(house);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          console.log("An error happened");
        }
      );

      // ===================== HOUSE =====================
      // ====================================================================================================================
      // ===================== TOWER1 =====================

      const towerBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
      });
      towerBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(towerBody);

      loader.load(
        "models/tower.glb",
        function (gltf) {
          const tower = gltf.scene;
          tower.position.set(5, -0.4, -5);
          tower.rotation.y = Math.PI / 4;
          tower.scale.set(0.7, 0.7, 0.7);
          scene.add(tower);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          console.log("An error happened");
        }
      );

      // ===================== TOWER1 =====================
      // ====================================================================================================================
      // ===================== TOWER2 =====================

      loader.load(
        "models/water_tower.glb",
        function (gltf) {
          const tower = gltf.scene;
          tower.position.set(-6.5, -0.4, -6.5);
          tower.rotation.y = Math.PI / 4;
          tower.scale.set(0.04, 0.04, 0.04);
          scene.add(tower);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          console.log("An error happened");
        }
      );

      // ===================== TOWER2 =====================
      // ====================================================================================================================
      // =================== ANIMATION ===================

      function animate() {
        requestAnimationFrame(animate);

        updatePlayerPosition();
        camera.position.copy(playerMesh.position);
        camera.position.y += 1.2;

        treeBody1.position.copy(treeBody1.position);
        treeBody1.quaternion.copy(treeBody1.quaternion);

        treeBody2.position.copy(treeBody2.position);
        treeBody2.quaternion.copy(treeBody2.quaternion);

        playerBody.position.copy(playerMesh.position);
        playerBody.quaternion.copy(playerMesh.quaternion);

        world.fixedStep();

        renderer.render(scene, camera);
      }
      animate();

      // =================== ANIMATION ===================
    </script>
  </body>
</html>
